/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Config file for defining DSL2 per module options and publishing paths
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Available keys to override module options:
        ext.args   = Additional arguments appended to command in module.
        ext.args2  = Second set of arguments appended to command in module (multi-tool modules).
        ext.args3  = Third set of arguments appended to command in module (multi-tool modules).
        ext.prefix = File name prefix for output files.
----------------------------------------------------------------------------------------
*/

process {
    withName: '.*' {
        errorStrategy = { task.exitStatus in ([130..145] + [104, 155, 255]) ? 'retry' : 'finish' }
    }

    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].tokenize('_')[0].toLowerCase()}" },
        mode: params.publish_dir_mode,
        saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
    ]

    withName: SAMPLESHEET_CHECK {
        publishDir = [
            path: { "${params.outdir}/pipeline_info" },
            mode: params.publish_dir_mode,
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
        ]
    }

    withName: 'SNPEFF_DOWNLOAD' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { params.outdir_cache ? "${params.outdir_cache}/": "${params.outdir}/cache/snpeff/" }
        ]
    }

    withName: 'ENSEMBLVEP_DOWNLOAD' {
        ext.args         = '--AUTO c --CONVERT --NO_BIOPERL --NO_HTSLIB --NO_TEST --NO_UPDATE'
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { params.outdir_cache ? "${params.outdir_cache}/": "${params.outdir}/cache/vep/" }
        ]
    }

    withName: 'CREATE_INTERVALS_BED' {
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/intervals" },
            pattern: "*bed"
        ]
    }

    withName: 'GATK4_INTERVALLISTTOBED' {
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/intervals" },
            pattern: "*bed"
        ]
    }

    withName: 'TABIX_BGZIPTABIX_INTERVAL_SPLIT' {
        ext.prefix       = {"${meta.patient}"}
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/intervals" },
            pattern: "*bed.gz"
        ]
    }

    withName: 'BWAMEM2_INDEX' {
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference" },
            pattern: "bwamem2"
        ]
    }

    withName: 'GATK4_CREATESEQUENCEDICTIONARY' {
        ext.when         = { !params.dict }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/dict" },
            pattern: "*dict"
        ]
    }

    withName: 'SAMTOOLS_FAIDX' {
        ext.when         = { !params.fasta_fai }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/fai" },
            pattern: "*fai"
        ]
    }

    withName: 'TABIX_DBSNP' {
        ext.when         = { !params.dbsnp_tbi && params.dbsnp }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/dbsnp" },
            pattern: "*vcf.gz.tbi"
        ]
    }

    withName: 'TABIX_GERMLINE_RESOURCE' {
        ext.when         = { !params.germline_resource_tbi && params.germline_resource }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/germline_resource" },
            pattern: "*vcf.gz.tbi"
        ]
    }

    withName: 'TABIX_KNOWN_INDELS' {
        ext.when         = { !params.known_indels_tbi && params.known_indels }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/known_indels" },
            pattern: "*vcf.gz.tbi"
        ]
    }

    withName: 'TABIX_KNOWN_SNPS' {
        ext.when         = { !params.known_snps_tbi && params.known_snps }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/known_snps" },
            pattern: "*vcf.gz.tbi"
        ]
    }

    withName: 'TABIX_PON' {
        ext.when         = { !params.pon_tbi && params.pon }
        publishDir       = [
            enabled: (params.save_reference || params.build_only_index),
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/reference/pon" },
            pattern: "*vcf.gz.tbi"
        ]
    }

    withName: 'UNZIP_ALLELES|UNZIP_LOCI|UNZIP_GC|UNZIP_RT' {
        publishDir       = [
            enabled: false
        ]
    }

    withName: FASTQC {
        // ext.args = '--quiet'
        publishDir       = [
            [
                path: { "${params.outdir}/${meta.patient}/fastqc/" },
                mode: params.publish_dir_mode,
                pattern: "*{html,zip}"
            ]
        ]
    }

    withName: 'FASTP' {
        ext.args = [ "",
            !params.trim_fastq             ? "--disable_adapter_trimming"                 : "", // Disable adapter trimming
            params.clip_r1 > 0             ? "--trim_front1 ${params.clip_r1}"            : "", // Remove bp from the 5' end of read 1
            params.clip_r2   > 0           ? "--trim_front2 ${params.clip_r2}"            : "", // Remove bp from the 5' end of read 2
            params.three_prime_clip_r1 > 0 ? "--trim_tail1 ${params.three_prime_clip_r1}" : "", // Remove bp from the 3' end of read 1 AFTER adapter/quality trimming has been performed
            params.three_prime_clip_r2 > 0 ? "--trim_tail2 ${params.three_prime_clip_r2}" : "", // Remove bp from the 3' end of read 2 AFTER adapter/quality trimming has been performed
            params.trim_nextseq            ? "--trim_poly_g"                              : "", // Apply the --nextseq=X option, to trim based on quality after removing poly-G tails
            params.split_fastq > 0         ? "--split_by_lines ${params.split_fastq * 4}" : ""
        ].join(" ").trim()
        publishDir = [
            [
                path: { "${params.outdir}/${meta.sample}/qc_reports/fastp/" },
                mode: params.publish_dir_mode,
                pattern: "*.{html,json,log}"
            ],
            [
                enabled: params.save_trimmed || params.save_split_fastqs,
                path: { "${params.outdir}/${meta.sample}/fastp/" },
                mode: params.publish_dir_mode,
                pattern: "*.fastp.fastq.gz"
            ]
        ]
    }

    withName: "PARABRICKS_FQ2BAM" {
		publishDir       = [
            mode: params.publish_dir_mode,
            path: { 
				def label = meta.status == 1 ? 'tumor' : 'normal'
				"${params.outdir}/${meta.patient}/alignment/${label}/" 
				// "${params.outdir}/${meta.patient}/alignment/"
			},
            pattern: "*{bam,bai,duplicate*metrics*,qc*metrics*}",
            // Only save if (save_output_as_bam AND (no_markduplicates OR save_mapped ))
            saveAs: { params.aligner == "fq2bam" ? "fq2bam/${it}" : null }
        ]
        ext.when         = { params.aligner == "fq2bam" }
    }

    withName: "BWAMEM2_MEM" {
		publishDir       = [
            mode: params.publish_dir_mode,
            path: { 
				def label = meta.status == 1 ? 'tumor' : 'normal'
				"${params.outdir}/${meta.patient}/alignment/${label}/" 
				// "${params.outdir}/${meta.patient}/alignment/"
			},
            pattern: "*{bam,bai,duplicate*metrics*}",
            // Only save if (save_output_as_bam AND (no_markduplicates OR save_mapped ))
            saveAs: { params.aligner == "fq2bam" ? "fq2bam/${it}" : null }
        ]
        ext.when         = { params.aligner == "bwa-mem2" }
    }

    withName: "(BWAMEM.*_MEM|DRAGMAP_ALIGN|SENTIEON_BWAMEM)" {
        ext.prefix       = { params.split_fastq > 1 ? "${meta.id}".concat('.').concat(reads.get(0).name.tokenize('.')[0]) : "${meta.id}.sorted" }
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/alignment/" },
            pattern: "*bam",
            // Only save if save_output_as_bam AND
            // (save_mapped OR no_markduplicates OR sentieon_dedup) AND
            // only a single BAM file per sample
            saveAs: {
                if (params.save_output_as_bam &&
                    (
                        params.save_mapped ||
                        (params.skip_tools && params.skip_tools.split(',').contains('markduplicates')) &&
                        !(params.tools && params.tools.split(',').contains('sentieon_dedup'))
                    ) && (meta.size * meta.num_lanes == 1)
                ) { "${meta.patient}/mapped/${it}" }
                else { null }
            }
        ]
    }

    withName: "(BWAMEM.*_MEM|DRAGMAP_ALIGN)" {
        // Markduplicates Spark NEEDS name-sorted reads or runtime goes through the roof
        // However if it's skipped, reads need to be coordinate-sorted
        // Only name sort if Spark for Markduplicates + duplicate marking is not skipped
        // Currently SENTIEON_BWAMEM only supports coordinate sorting the reads.
        ext.args2        = { params.use_gatk_spark && params.use_gatk_spark.contains('markduplicates') && (!params.skip_tools || (params.skip_tools && !params.skip_tools.split(',').contains('markduplicates'))) ? '-n' : '' }
    }

    withName: "BWAMEM.*_MEM|SENTIEON_BWAMEM" {
        // Using -B 3 for tumor samples
        ext.args         = { meta.status == 1 ? "-K 100000000 -Y -B 3 -R ${meta.read_group}" : "-K 100000000 -Y -R ${meta.read_group}" }
    }

    withName: 'MERGE_BAM|INDEX_MERGE_BAM' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { 
				def label = meta.status == 1 ? 'tumor' : 'normal'
				"${params.outdir}/${meta.patient}/alignment/${label}/" 
				// "${params.outdir}/${meta.patient}/alignment/"
			},
            pattern: "*{bam,bai,duplicate*metrics*}",
            // Only save if (save_output_as_bam AND (no_markduplicates OR save_mapped ))
            saveAs: { params.aligner == "fq2bam" ? "fq2bam/${it}" : null }
        ]
    }

    withName: 'MERGE_BAM' {
        ext.prefix = { "${meta.id}.sorted" }
    }


    withName: 'CRAM_TO_BAM_FINAL' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/mapped/" },
            pattern: "*{bam,bai}",
        ]
    }

    withName: 'PICARD_COLLECTMULTIPLEMETRICS' {
        publishDir = [
            mode: params.publish_dir_mode,
            path: { 
				 def label = meta.status == 1 ? 'tumor' : 'normal'
            	return "${params.outdir}/${meta.patient}/picard_qc/${label}/"
				// "${params.outdir}/${meta.patient}/picard_qc/" 
			},
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: 'PICARD_COLLECTWGSMETRICS' {
        publishDir = [
            mode: params.publish_dir_mode,
            path: { 
				 def label = meta.status == 1 ? 'tumor' : 'normal'
            	return "${params.outdir}/${meta.patient}/picard_qc/${label}/"
				// "${params.outdir}/${meta.patient}/picard_qc/" 
			},
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

	withName: 'PARABRICKS_BAMMETRICS' {
        publishDir = [
            mode: params.publish_dir_mode,
            path: { 
				 def label = meta.status == 1 ? 'tumor' : 'normal'
            	return "${params.outdir}/${meta.patient}/parabricks_qc/${label}/"
				// "${params.outdir}/${meta.patient}/picard_qc/" 
			},
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

	withName: 'GPU_COLLECTMULTIPLEMETRICS' {
        publishDir = [
            mode: params.publish_dir_mode,
            path: { 
				 def label = meta.status == 1 ? 'tumor' : 'normal'
            	return "${params.outdir}/${meta.patient}/parabricks_multiple_metrics/${label}/"
				// "${params.outdir}/${meta.patient}/picard_qc/" 
			},
			pattern: "**",
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: 'GATK4_ESTIMATELIBRARYCOMPLEXITY' {
        publishDir = [
            mode: params.publish_dir_mode,
            path: { 
				def label = meta.status == 1 ? 'tumor' : 'normal'
            	return "${params.outdir}/${meta.patient}/gatk_qc/${label}/"
				// "${params.outdir}/${meta.patient}/gatk_qc/" 
			},
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: 'SAMTOOLS_STATS' {
        ext.when         = { !(params.skip_tools && params.skip_tools.split(',').contains('samtools')) }
        ext.prefix       = { "${meta.id}.sorted.cram" }
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/samtools/" },
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
        ]
    }

    withName: 'MOSDEPTH' {
        ext.args = { !params.wes ? "-n --fast-mode --by 500" : ""}
        ext.prefix       = {
            if (params.tools && params.tools.split(',').contains('sentieon_dedup')) {
                "${meta.id}.dedup"
            } else if (params.skip_tools && params.skip_tools.split(',').contains('markduplicates')) {
                "${meta.id}.sorted"
            } else {
                "${meta.id}.md"
            }
        }
        ext.when         = { !(params.skip_tools && params.skip_tools.split(',').contains('mosdepth')) }
        publishDir = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/mosdepth/" },
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename },
        ]
    }

    withName: 'GATK4_BASERECALIBRATOR|GATK4_BASERECALIBRATOR_SPARK' {
        ext.prefix       = { meta.num_intervals <= 1 ? "${meta.id}.recal" : "${meta.id}_${intervals.simpleName}.recal" }
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/" },
            pattern: "*table",
            saveAs: { meta.num_intervals > 1 ? null : "recal_table/${it}" }
        ]
    }

    withName: 'GATK4_APPLYBQSR|GATK4_APPLYBQSR_SPARK' {
        ext.prefix       = { meta.num_intervals <= 1 ? "${meta.id}.recal" : "${meta.id}_${intervals.simpleName}.recal" }
        publishDir       = [
            enabled: params.save_mapped,
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/"},
            pattern: "*cram",
            saveAs: { meta.num_intervals > 1 ? null : "/recalibrated/${it}" }
        ]
    }

    withName: 'CRAM_TO_BAM_RECAL' {
        ext.prefix       = { "${meta.id}.recal" }

        publishDir       = [
            enabled: params.save_mapped,
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/recalibrated/" },
            pattern: "*{recal.bam,recal.bam.bai}"
        ]
    }

    withName: 'GATK4_GATHERBQSRREPORTS' {
        ext.prefix       = {"${meta.id}.recal"}

        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/recal_table/" },
            pattern: "*table",
        ]
    }
    withName: 'CRAM_TO_BAM' {
        ext.args         = "-b"
    }

    withName: 'BAM_TO_CRAM' {
        // BAM provided for step Markduplicates either run through MD or Convert -> then saved as sorted.cram (convert) or md.cram (md directly)
        // BAM files provided for step prepare_recal are converted and run through BQSR -> then saved as md.cram
        // BAM files provided for step recal are converted and run through BQSR II -> then saved as md.cram
        ext.args         = "-C"
        ext.prefix       = { "${meta.id}.converted" }
        publishDir       = [
            enabled: !params.save_output_as_bam,
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/mapped/" },
            pattern: "*{cram,crai}"
        ]
    }

    withName: '(BAM_MARKDUPLICATES|BAM_MARKDUPLICATES_SPARK):CRAM_QC_MOSDEPTH_SAMTOOLS:SAMTOOLS_STATS' {

        ext.prefix       = { "${meta.id}.md.cram" }
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/samtools/" },
            saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
        ]
    }

    withName: 'BAM_TO_CRAM_MAPPING' {
        // Run only when mapping should be saved as CRAM or when no MD is done

            (
                (params.skip_tools && params.skip_tools.split(',').contains('markduplicates')) &&
                !(params.tools && params.tools.split(',').contains('sentieon_dedup'))
            )
        ext.prefix       = { "${meta.id}.sorted" }
        publishDir       = [
            // Never publish if BAM only should be published
            enabled: !params.save_output_as_bam,
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/mapped/" },
            pattern: "*{cram,crai}"
        ]
    }

    // withName: 'GATK4_ESTIMATELIBRARYCOMPLEXITY' {
    //     ext.prefix       = { "${meta.id}.md.cram" }

    //     publishDir       = [
    //         mode: params.publish_dir_mode,
    //         path: { "${params.outdir}/${meta.patient}/markduplicates/" },
    //         pattern: "*metrics"
    //     ]
    // }

    withName: 'GATK4_MARKDUPLICATES' {
        ext.args         = '-REMOVE_DUPLICATES false -VALIDATION_STRINGENCY LENIENT'
        ext.prefix       = { "${meta.id}.md.cram" }

        publishDir       = [
            [
                enabled: !params.save_output_as_bam,
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/markduplicates/" },
                pattern: "*{cram,crai}"
            ],
            [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/Reports/" },
                pattern: "*metrics",
                saveAs: { !(params.skip_tools && params.skip_tools.split(',').contains('markduplicates_report')) ? "markduplicates/${meta.patient}/${it}" : null}
            ]
        ]
    }

    withName: 'GATK4_MARKDUPLICATES_SPARK' {
        ext.args         = '--remove-sequencing-duplicates false -VS LENIENT'
        ext.prefix       = { "${meta.id}.md.cram" }
        publishDir       = [
            enabled: !params.save_output_as_bam,
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/markduplicates/" },
            pattern: "*{cram,crai}"
        ]
    }

    withName: 'INDEX_MARKDUPLICATES' {
        publishDir       = [
            enabled: !params.save_output_as_bam,
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/markduplicates/" },
            pattern: "*{cram,crai}"
        ]
    }

    withName: 'CRAM_TO_BAM' {

        if (params.tools && params.tools.split(',').contains('sentieon_dedup')) {
            ext.prefix       = { "${meta.id}.dedup" }
            publishDir       = [
                enabled: params.save_output_as_bam,
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/sentieon_dedup/" },
                pattern: "*{dedup.bam,dedup.bam.bai}"
            ]
        } else {
            ext.prefix       = { "${meta.id}.md" }
            publishDir       = [
                enabled: params.save_output_as_bam,
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/markduplicates/" },
                pattern: "*{md.bam,md.bam.bai}"
            ]
        }
    }

    withName: '.*BAM_MSISENSORPRO:MSISENSORPRO_MSISOMATIC' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/msisensorpro/" },
                pattern: "*{_dis*,_germline*,_somatic*,_report*}"
        ]
    }

    withName: CUSTOM_DUMPSOFTWAREVERSIONS {
        publishDir = [
            path: { "${params.outdir}/pipeline_info" },
            mode: params.publish_dir_mode,
            pattern: '*_versions.yml'
        ]
    }

    withName: '.*SVABA' {
        ext.prefix       = { "${meta.id}.svaba" }
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/svaba/" },
                pattern: "*{vcf.gz,txt.gz,vcf*,bam,.command.*}"
            ]
    }

    withName: '.*GRIDSS_GRIDSS*' {
        ext.prefix = { "${meta.id}.gridss" }
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/gridss/" },
                pattern: "*{vcf.bgz*,vcf.gz,txt.gz,vcf*,bam,.command.*}"
            ]
    }

    withName: 'GRIDSS_ASSEMBLE_GATHER' {
        ext.prefix = { "${meta.id}.gridss" }
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/gridss/" },
                pattern: "*{bam}"
            ]
    }

    withName: 'GRIDSS_CALL' {
        ext.prefix = { "${meta.id}.gridss" }
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/gridss/" },
                pattern: "*{vcf.bgz*,vcf.gz,txt.gz,vcf*,bam,.command.*}"
            ]
    }

    withName: '.*GRIDSS_SOMATIC' {
        ext.prefix = { "${meta.id}.gridss" }
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/gridss/" },
                pattern: "*{vcf.bgz*,vcf.gz,txt.gz,vcf*,bam,.command.*}"
            ]
    }

    withName: '.*JUNCTION_FILTER' {

        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/gridss/" },
                pattern: "*{.rds*,.command.*}"
            ]
    }

    withName: 'AMBER' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/amber/" },
            saveAs: { filename -> filename.equals('versions.yml') ? null : "${filename}" },
        ]
    }

    withName: 'COBALT' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/cobalt/" },
            saveAs: { filename -> filename.equals('versions.yml') ? null : "${filename}" },
        ]
    }

    withName: 'PURPLE' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/" }, // omit purple because purple/ is emitted
            saveAs: { filename -> filename.equals('versions.yml') ? null : "${filename}" },
        ]
    }

    withName: '.*TUMOR_FRAGCOUNTER:.*' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/fragcounter/tumor/" },
                pattern: "*{.rds,.bw,cov*,.command.*,1kb_*}"
        ]
    }

    withName: '.*NORMAL_FRAGCOUNTER:.*' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/fragcounter/normal/" },
                pattern: "*{.rds,.bw,cov*,.command.*,1kb_*}"
        ]
    }

    withName: '.*TUMOR_DRYCLEAN:DRYCLEAN' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/dryclean/tumor/" },
                pattern: "*{cov.rds,.command.*}"
        ]
    }

    withName: '.*NORMAL_DRYCLEAN:DRYCLEAN' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/dryclean/normal/" },
                pattern: "*{cov.rds,.command.*}"
        ]
    }

    withName: '.*MAKE_HET_SITES' {
        publishDir       = [
            mode: params.publish_dir_mode,
            path: { "${params.outdir}/${meta.patient}/amber/" },
            pattern: "*{.txt*,.command.*}"
        ]
    }

    withName: '.*CBS' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/cbs/" },
                pattern: "*{.rds,.command.*}"
        ]
    }

    withName: '.*RETIER_WHITELIST_JUNCTIONS' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/jabba/" },
                pattern: "*{.rds*,.vcf*}"
        ]
    }

    withName: '.*JABBA' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/jabba/" },
                pattern: "*{.rds*,.vcf,.seg,.png,.txt,.command.*}"
        ]
    }

    withName: '.*NON_INTEGER_BALANCE' {

        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/non_integer_balance/" },
                pattern: "*{.rds*,.command.*}"
        ]
    }

    withName: '.*EVENTS' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/events/" },
                pattern: "*{.rds*,.command.*}"
        ]
    }

    withName: '.*FUSIONS' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/fusions/" },
                pattern: "*{.rds*,.command.*, .tsv}"
        ]
    }

    withName: '.*LP_PHASED_BALANCE' {

        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/lp_phased_balance/" },
                pattern: "*{.rds*,.command.*}"
        ]
    }

    withName: '.*STRELKA_SOMATIC' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/strelka/somatic/" },
                pattern: "*{vcf.gz,txt.gz,vcf*,.command.*}"
            ]
    }

    withName: '.*STRELKA_GERMLINE' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/strelka/germline/" },
                pattern: "*{vcf.gz,txt.gz,vcf*,.command.*}"
            ]
    }

    withName: '.*SAGE_SOMATIC|SAGE_PASS_FILTER' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/sage/somatic/" },
                pattern: "*{vcf.gz,txt.gz,vcf*,*.dict,.command.*}"
            ]
    }

    withName: '.*SAGE_GERMLINE' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/sage/germline/" },
                pattern: "*{vcf.gz,txt.gz,vcf*,*.dict,.command.*}"
            ]
    }

    withName: '.*SAGE_TUMOR_ONLY_FILTER' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/sage/somatic/tumor_only_filter/" },
                pattern: "*{vcf.gz,txt.gz,vcf*,*.dict,.command.*}"
            ]
    }

    withName: '.*VCF_PAVE_SOMATIC:PAVE' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/pave/somatic/" },
                pattern: "*{.vcf*,.tbi*}"
        ]
    }

    withName: '.*VCF_PAVE_GERMLINE:PAVE' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/pave/germline/" },
                pattern: "*{.vcf*,.tbi*}"
        ]
    }

    withName: '.*VCF_SNPEFF_SOMATIC:.*' {
        ext.prefix       = {"${meta.patient}_somatic"}
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/snpeff/somatic/" },
                pattern: "*{.vcf*,.txt*,.html*,.csv*,.bcf*}"
        ]
    }

    withName: '.*VCF_SNPEFF_GERMLINE:.*' {
        ext.prefix       = {"${meta.patient}_germline"}
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/snpeff/germline/" },
                pattern: "*{.vcf*,.txt*,.html*,.csv*,.bcf*}"
        ]
    }

    withName: '.*VCF_SNV_MULTIPLICITY:SNV_MULTIPLICITY' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/snv_multiplicity/" },
                pattern: "*{.rds*}"
        ]
    }
    withName: '.*VCF_FUSIONS_CNA_ONCOKB_ANNOTATOR:ONCOKB_ANNOTATOR' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/oncokb/" },
                pattern: "*{.maf*,.tsv*}"
        ]
    }

    withName: '.*SIGPROFILERASSIGNMENT' {
        publishDir       = [
			[
				mode: params.publish_dir_mode,
				path: { "${params.outdir}/${meta.patient}/sigprofilerassignment/" },
				pattern: "*/**/*{.txt,.all}"
			], [
				mode: params.publish_dir_mode,
				path: { "${params.outdir}/${meta.patient}/sigprofilerassignment/" },
				pattern: "*/**/**/*{.txt,.all}"
			], [
				mode: params.publish_dir_mode,
				path: { "${params.outdir}/${meta.patient}/sigprofilerassignment/" },
				pattern: "*/**/**/**/*{.txt,.all}"
			], [
				mode: params.publish_dir_mode,
				path: { "${params.outdir}/${meta.patient}/sigprofilerassignment/" },
				pattern: "*/**/**/**/**/*{.txt,.all}"
			]
		]
		
    }

	withName: '.*FFPE_IMPACT_FILTER' {
        publishDir       = [
			mode: params.publish_dir_mode,
			path: { "${params.outdir}/${meta.patient}/ffpe_impact/" },
			pattern: "*.vcf*"
		]
    }

    withName: '.*HRDETECT' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/hrdetect/" },
                pattern: "*{.rds*,.txt,.command.*}"
        ]
    }

    withName: '.*ONENESS_TWONESS' {
        publishDir       = [
                mode: params.publish_dir_mode,
                path: { "${params.outdir}/${meta.patient}/onenesstwoness/" },
                pattern: "*{.rds*,.txt,.command.*}"
        ]
    }

    withName: 'UNZIP.*|UNTAR.*|TABIX.*|BUILD_INTERVALS|CREATE_INTERVALS_BED|CUSTOM_DUMPSOFTWAREVERSIONS|VCFTOOLS|BCFTOOLS.*' {
        cpus            = { check_max( 1 * task.attempt, 'cpus' ) }
        memory          = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'FASTQC'{
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 16.GB * task.attempt, 'memory' ) }
        maxForks        = 2
        errorStrategy   = 'retry'
        maxRetries      = 50
        maxErrors       = 50
        time            = { check_max( 8.h  * task.attempt, 'time'    ) }
    }
    withName: 'FASTP'{
        cpus            = { check_max( 12 * task.attempt, 'cpus' ) }
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'BWAMEM2_MEM|BWAMEM2_MEM' {
        cpus            = { check_max( 24 * task.attempt, 'cpus' ) }
        memory          = { check_max( 72.GB * task.attempt, 'memory' ) }
    }
    withName: 'PARABRICKS_FQ2BAM' {
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 72.GB * task.attempt, 'memory' ) }
        time            = { check_max( 8.h  * task.attempt, 'time'    ) }
        // accelerator     = { check_max( 1 * task.attempt, 'accelerator') }
    }
    withName: 'SAMTOOLS_MERGE|SAMTOOLS_INDEX' {
        cpus            = { check_max( 16 * task.attempt, 'cpus' ) }
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName: 'GATK4_MARKDUPLICATES|GATK4_MARKDUPLICATESSPARK' {
        cpus           = { check_max( 6 * task.attempt, 'cpus' ) }
        memory         = { check_max( 30.GB * task.attempt, 'memory' ) }
    }
    withName:'GATK4_APPLYBQSR|GATK4_APPLYBQSR_SPARK|GATK4_BASERECALIBRATOR|GATK4_BASERECALIBRATOR_SPARK|GATK4_GATHERBQSRREPORTS'{
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName:'MOSDEPTH'{
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName:'STRELKA.*|MANTA.*' {
        cpus            = { check_max( 10 * task.attempt, 'cpus' ) }
        memory          = { check_max( 8.GB * task.attempt, 'memory' ) }
    }
    withName:'SAMTOOLS_CONVERT'{
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName:'GATK4_MERGEVCFS'{
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
    }
    withName:'PARABRICKS_BAMMETRICS' {
        cpus = 12
        memory = { check_max( 72.GB * task.attempt, 'memory' ) }
        time = { check_max( 8.h  * task.attempt, 'time'    ) }
    }
    withName: 'MULTIQC' {
        cpus            = { check_max( 1 * task.attempt, 'cpus' ) }
        memory          = { check_max( 1.GB * task.attempt, 'memory' ) }
    }
    withName: 'CRAM_TO_BAM|BAM_TO_CRAM' {
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 32.GB * task.attempt, 'memory' ) }
        time            = { check_max( 24.h  * task.attempt, 'time'   ) }
    }
    withName: 'SVABA' {
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 64.GB * task.attempt, 'memory' ) }
        time            = { check_max( 48.h  * task.attempt, 'time'    ) }
    }
    withName: 'GRIDSS_GRIDSS' {
        errorStrategy   = "retry"
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 32.GB * task.attempt, 'memory' ) }
        time            = { check_max( 48.h  * task.attempt, 'time'    ) }
    }
    withName: 'GRIDSS_ASSEMBLE_SCATTER' {
        errorStrategy   = "retry"
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 48.GB * task.attempt, 'memory' ) }
        time            = { check_max( 48.h  * task.attempt, 'time'    ) }
    }
    withName: 'GRIDSS_ASSEMBLE_GATHER' {
        errorStrategy   = "retry"
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 48.GB * task.attempt, 'memory' ) }
        time            = { check_max( 48.h  * task.attempt, 'time'    ) }
    }
    withName: 'GRIDSS_CALL' {
        errorStrategy   = "retry"
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 48.GB * task.attempt, 'memory' ) }
        time            = { check_max( 48.h  * task.attempt, 'time'    ) }
    }
    withName: 'GRIDSS_SOMATIC' {
        errorStrategy   = "retry"
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 48.GB * task.attempt, 'memory' ) }
        time            = { check_max( 16.h  * task.attempt, 'time'    ) }
    }
    withName: 'JUNCTION_FILTER' {
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 72.GB * task.attempt, 'memory' ) }
        time            = { check_max( 8.h  * task.attempt, 'time'    ) }
    }
    withName: 'HETPILEUPS' {
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 8.GB * task.attempt, 'memory' ) }
        time            = { check_max( 16.h  * task.attempt, 'time'    ) }
    }
    withName: 'FRAGCOUNTER' {
        cpus            = { check_max( 3 * task.attempt, 'cpus' ) }
        memory          = { check_max( 4.GB * task.attempt, 'memory' ) }
        time            = { check_max( 8.h  * task.attempt, 'time'   ) }
    }
    withName: 'DRYCLEAN' {
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 48.GB * task.attempt, 'memory' ) }
        time            = { check_max( 1.h  * task.attempt, 'time'    ) }
    }
    withName: 'ASCAT_SEG' {
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 6.GB * task.attempt, 'memory' ) }
        time            = { check_max( 2.h  * task.attempt, 'time'    ) }
    }
    withName: 'CBS' {
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 32.GB * task.attempt, 'memory' ) }
        time            = { check_max( 1.h  * task.attempt, 'time'    ) }
    }
    withName: 'SAGE_SOMATIC' {
	    cpus            = { check_max( 20 * task.attempt, 'cpus' ) }
        memory          = { check_max( 64.GB * task.attempt, 'memory' ) }
        time            = { check_max( 5.h  * task.attempt, 'time'    ) }
    }
    withName: 'SAGE_GERMLINE' {
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 16.GB * task.attempt, 'memory' ) }
        time            = { check_max( 1.h  * task.attempt, 'time'    ) }
    }
    withName: 'COERCE_SEQNAMES' {
        cpus             = { check_max( 2     * task.attempt, 'cpus'    ) }
        memory           = { check_max( 12.GB * task.attempt, 'memory'  ) }
        time             = { check_max( 16.h   * task.attempt, 'time'    ) }
    }
    withName: 'JABBA' {
        cpus            = { check_max( 16 * task.attempt, 'cpus' ) }
        memory          = { check_max( 80.GB * task.attempt, 'memory' ) }
        time            = { check_max( 16.h  * task.attempt, 'time'    ) }
    }
    withName: 'EVENTS' {
        cpus            = { check_max( 3 * task.attempt, 'cpus' ) }
        memory          = { check_max( 8.GB * task.attempt, 'memory' ) }
        time            = { check_max( 4.h  * task.attempt, 'time'    ) }
    }
    withName: 'FUSIONS' {
        cpus            = { check_max( 5 * task.attempt, 'cpus' ) }
        memory          = { check_max( 80.GB * task.attempt, 'memory' ) }
        time            = { check_max( 4.h  * task.attempt, 'time'    ) }
    }
    withName: 'NON_INTEGER_BALANCE' {
        cpus            = { check_max( 10 * task.attempt, 'cpus' ) }
        memory          = { check_max( 16.GB * task.attempt, 'memory' ) }
        time            = { check_max( 4.h  * task.attempt, 'time'    ) }
    }
    withName: 'LP_PHASED_BALANCE' {
        cpus            = { check_max( 16 * task.attempt, 'cpus' ) }
        memory          = { check_max( 16.GB * task.attempt, 'memory' ) }
        time            = { check_max( 8.h  * task.attempt, 'time'    ) }
    }
    withName: 'HRDETECT' {
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 6.GB * task.attempt, 'memory' ) }
        time            = { check_max( 6.h  * task.attempt, 'time'    ) }
    }
    withName: 'SIGPROFILERASSIGNMENT' {
        cpus            = { check_max( 2 * task.attempt, 'cpus' ) }
        memory          = { check_max( 8.GB * task.attempt, 'memory' ) }
        time            = { check_max( 1.h  * task.attempt, 'time'    ) }
    }
    withName: 'SNPEFF_SNPEFF' {
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 32.GB * task.attempt, 'memory' ) }
        time            = { check_max( 4.h  * task.attempt, 'time'    ) }
    }
    withName: 'SNPEFF_VCF_TO_BCF' {
        cpus            = { check_max( 4 * task.attempt, 'cpus' ) }
        memory          = { check_max( 32.GB * task.attempt, 'memory' ) }
        time            = { check_max( 4.h  * task.attempt, 'time'    ) }
    }
    withName: 'STRELKA_SOMATIC' {
	    cpus            = { check_max( 16 * task.attempt, 'cpus' ) }
        memory          = { check_max( 64.GB * task.attempt, 'memory' ) }
        time            = { check_max( 5.h  * task.attempt, 'time'    ) }
    }
    withName: 'STRELKA_GERMLINE' {
        cpus            = { check_max( 8 * task.attempt, 'cpus' ) }
        memory          = { check_max( 16.GB * task.attempt, 'memory' ) }
        time            = { check_max( 1.h  * task.attempt, 'time'    ) }
    }
    withName:CUSTOM_DUMPSOFTWAREVERSIONS {
        cache = false
    }
}
